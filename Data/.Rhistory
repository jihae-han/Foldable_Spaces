walking$CountGait[i,]$CountGait <- count
}
#--------Changes in Acceleration (m/s^2)---------# Not Useful
checksign <- function(value) {
if (value >= 0)
return(TRUE)
else (value < 0)
return(FALSE)
}
threshold <- 0.1 #slower than 0.1m/s is considered a pause just looking around
#calculate changes in acceleration
for (i in 1:nrow(walkdata)) { #nrow(walkdata)
count <- 0
tempcount <- 0
currentaccel <- TRUE
for (index in 2:length(walkdata[i,]$Acce)) {
if (checksign(walkdata[i,]$Acce[index]) != checksign(walkdata[i,]$Acce[index-1])) {
tempcount <- tempcount + 1
if (tempcount > 59) { #if the acceleration/decceration is more than a second
count <- count + 1
tempcount <- 0
}
}
}
walking[i,]$CountGait <- count
}
#calculate pauses
walking
COGspatial
#--------Changes in Acceleration (m/s^2)---------# Not Useful
checksign <- function(value) {
if (value >= 0)
return(TRUE)
else (value < 0)
return(FALSE)
}
threshold <- 0.1 #slower than 0.1m/s is considered a pause just looking around
#calculate changes in acceleration
for (i in 1:nrow(walkdata)) { #nrow(walkdata)
count <- 0
tempcount <- 0
currentaccel <- TRUE
for (index in 2:length(walkdata[i,]$Acce)) {
if (checksign(walkdata[i,]$Acce[index]) != checksign(walkdata[i,]$Acce[index-1])) {
tempcount <- tempcount + 1
if (tempcount > 59) { #if the acceleration/decceration is more than a second
count <- count + 1
tempcount <- 0
}
}
}
walking[i,]$CountGait <- count
}
#input into COGspatial
COGspatial$CountGait <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
COGspatial[i,]$CountGait <- sum(walking[index,]$CountGait)
}
else if (length(index)>0){
COGspatial[i,]$CountGait <- walking[index,]$CountGait
}
}
friedman.test(CountGait ~ Condition | ID, data = COGspatial)
#--------Changes in Acceleration (m/s^2)---------# Not Useful
checksign <- function(value) {
if (value >= 0)
return(TRUE)
else (value < 0)
return(FALSE)
}
threshold <- 0.1 #slower than 0.1m/s is considered a pause just looking around
#calculate changes in acceleration
for (i in 1:nrow(walkdata)) { #nrow(walkdata)
count <- 0
tempcount <- 0
currentaccel <- TRUE
for (index in 2:length(walkdata[i,]$Acce)) {
if (checksign(walkdata[i,]$Acce[index]) != checksign(walkdata[i,]$Acce[index-1])) {
tempcount <- tempcount + 1
if (tempcount > 59) { #if the acceleration/decceration is more than a second
count <- count + 1
tempcount <- 0
}
}
}
walking[i,]$CountGait <- count
}
#input into COGspatial
COGspatial$CountGait <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
COGspatial[i,]$CountGait <- sum(walking[index,]$CountGait)
}
else if (length(index)>0){
COGspatial[i,]$CountGait <- walking[index,]$CountGait
}
}
#stats
friedman.test(CountGait ~ Condition | ID, data = COGspatial)
pw_countgait <- pairwise.wilcox.test(COGspatial$CountGait, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_countgait
createBoxplot(COGspatial,'CountGait',"Changes in Acceleration (sustained over min 1sec)",pw_countgait)
#--------Changes in Acceleration (m/s^2) to calculate continuous movement ---#
checksign <- function(value) {
if (value >= 0)
return(TRUE)
else (value < 0)
return(FALSE)
}
#calculate changes in acceleration
for (i in 1:nrow(walkdata)) { #nrow(walkdata)
count <- 0
tempcount <- 0
currentaccel <- TRUE
for (index in 2:length(walkdata[i,]$Acce)) {
if (checksign(walkdata[i,]$Acce[index]) != checksign(walkdata[i,]$Acce[index-1])) {
tempcount <- tempcount + 1
if (tempcount > 59) { #if the acceleration/decceration is more than a second
count <- count + 1
tempcount <- 0
}
}
}
walking[i,]$CountGait <- count
}
#input into COGspatial
COGspatial$CountGait <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
COGspatial[i,]$CountGait <- sum(walking[index,]$CountGait)
}
else if (length(index)>0){
COGspatial[i,]$CountGait <- walking[index,]$CountGait
}
}
#stats
friedman.test(CountGait ~ Condition | ID, data = COGspatial)
pw_countgait <- pairwise.wilcox.test(COGspatial$CountGait, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_countgait
createBoxplot(COGspatial,'CountGait',"Changes in Acceleration (sustained over min 1sec)",pw_countgait)
acc20
walkdata[1,]
acc20
walkdata[1,]$Acce
walkdata[1,]$Acce[1:10]
walking
#list&organise all files in folder
walking = data.frame(ID=NA, Condition=NA, Path=NA)
walking <- walking[FALSE,]
acc_path <- list.files(path = ".", pattern = "1AccordionTest")
ver_path <- list.files(path = ".", pattern = "2VertTest")
hor_path <- list.files(path = ".", pattern = "3HoriTest")
snr_path <- list.files(path = ".", pattern = "4StopFadeReset")
acc_raw <- file2walking(acc_path, "Acc", walking)
ver_raw <- file2walking(ver_path, "Ver", walking)
hor_raw <- file2walking(hor_path, "Hor", walking)
snr_raw <- file2walking(snr_path, "S&R", walking)
walking <- rbind(walking, acc_raw)
walking <- rbind(walking, ver_raw)
walking <- rbind(walking, hor_raw)
walking <- rbind(walking, snr_raw)
colnames(walking) <- c("ID", "Condition", "Path")
#Compute Data for Walking and organise dataframes into larger dataframe
walkdata <- data.frame(ID=NA, Condition=NA, Time=NA, X=NA, Y=NA, Dist=NA, Velo=NA, Acce=NA)
walking$Walked <- 0 #Walked is cognitive user estimation
for (i in 1:nrow(walking)){
walking[i,]$Walked <- COGspatial[getrowindex(COGspatial, walking[i,]$ID, walking[i,]$Condition),]$Walked
}
walking$TotalWalked <- 0
walking$TotalTime <- 0
walking$AveSpeed <- 0
walking$MaxSpeed <- 0
walking$MinAccel <- 0
walking$MaxAccel <- 0
walking$CountGait <- 0
walking$CountRest <- 0
walksample =data.frame(Time=NA, X=NA, Y=NA, Dist=NA, Velo=NA, Acce=NA)
for (i in 1:1){
tempwalk <- read.csv(toString(walking[i,]$Path), header = FALSE, sep = ",")
tempwalk <- tempwalk[c(2:4)]
colnames(tempwalk) <- c("Time", "X", "Y")
tempwalk$Dist <- 0
tempwalk$Velo <- 0
tempwalk$Acce <- 0
#distance
for (x in 2:nrow(tempwalk)){
tempwalk$Dist[x] <- sqrt((tempwalk$X[x]-tempwalk$X[x-1])^2 + (tempwalk$Y[x]-tempwalk$Y[x-1])^2)
}
tempwalk <- tempwalk[as.integer(which(tempwalk$Dist==max(tempwalk$Dist))):(nrow(tempwalk)-10*60),]
#tighten to 3min
if (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1]>0) {
tempwalk <- tail(tempwalk, 3*60*60)
}
#velocity
for (x in 2:nrow(tempwalk)){
if(tempwalk$Time[x]==tempwalk$Time[x-1]) {
tempwalk$Velo[x] <- tempwalk$Velo[x-1]
}
else {
tempwalk$Velo[x] <- tempwalk$Dist[x]/(tempwalk$Time[x]-tempwalk$Time[x-1])
}
}
#acceleration
for (x in 3:nrow(tempwalk)) {
if (tempwalk$Time[x]==tempwalk$Time[x-1])
{
tempwalk$Acce[x] <- tempwalk$Acce[x-1]
}
else{
tempwalk$Acce[x] <- (tempwalk$Velo[x]-tempwalk$Velo[x-1])/(tempwalk$Time[x]- tempwalk$Time[x-1])
}
}
walkdata <- rbind(c(walking$ID[i], walking$Condition[i],tempwalk))
walking[i,]$TotalWalked <- sum(tempwalk$Dist)/100
walking[i,]$TotalTime <- (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1])/60
walking[i,]$AveSpeed <- walking[i,]$TotalWalked/walking[i,]$TotalTime * (1/60)
walking[i,]$MaxSpeed <- max(tempwalk$Velo) * (1/100)
walking[i,]$MinAccel <- min(tempwalk$Acce) * (1/100)
walking[i,]$MaxAccel <- max(tempwalk$Acce) * (1/100)
}
for (i in 2:nrow(walking)){
tempwalk <- read.csv(toString(walking[i,]$Path), header = FALSE, sep = ",")
tempwalk <- tempwalk[c(2:4)]
colnames(tempwalk) <- c("Time", "X", "Y")
tempwalk$Dist <- 0
tempwalk$Velo <- 0
tempwalk$Acce <- 0
#distance
for (x in 2:nrow(tempwalk)){
tempwalk$Dist[x] <- sqrt((tempwalk$X[x]-tempwalk$X[x-1])^2 + (tempwalk$Y[x]-tempwalk$Y[x-1])^2)
}
tempwalk <- tempwalk[as.integer(which(tempwalk$Dist==max(tempwalk$Dist))):(nrow(tempwalk)-10*60),]
#tighten to 3min
if (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1]>0) {
tempwalk <- tail(tempwalk, 3*60*60)
}
#velocity
for (x in 2:nrow(tempwalk)){
if(tempwalk$Time[x]==tempwalk$Time[x-1]) {
tempwalk$Velo[x] <- tempwalk$Velo[x-1]
}
else {
tempwalk$Velo[x] <- tempwalk$Dist[x]/(tempwalk$Time[x]-tempwalk$Time[x-1])
}
}
#acceleration
for (x in 3:nrow(tempwalk)) {
if (tempwalk$Time[x]==tempwalk$Time[x-1])
{
tempwalk$Acce[x] <- tempwalk$Acce[x-1]
}
else{
tempwalk$Acce[x] <- (tempwalk$Velo[x]-tempwalk$Velo[x-1])/(tempwalk$Time[x]- tempwalk$Time[x-1])
}
}
walkdata <- rbind(walkdata,c(walking$ID[i], walking$Condition[i],tempwalk))
walking[i,]$TotalWalked <- sum(tempwalk$Dist)/100
walking[i,]$TotalTime <- (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1])/60
walking[i,]$AveSpeed <- walking[i,]$TotalWalked/walking[i,]$TotalTime * (1/60)
walking[i,]$MaxSpeed <- max(tempwalk$Velo) * (1/100)
walking[i,]$MinAccel <- min(tempwalk$Acce) * (1/10000)
walking[i,]$MaxAccel <- max(tempwalk$Acce) * (1/10000)
}
#list&organise all files in folder
walking = data.frame(ID=NA, Condition=NA, Path=NA)
walking <- walking[FALSE,]
acc_path <- list.files(path = ".", pattern = "1AccordionTest")
ver_path <- list.files(path = ".", pattern = "2VertTest")
hor_path <- list.files(path = ".", pattern = "3HoriTest")
snr_path <- list.files(path = ".", pattern = "4StopFadeReset")
acc_raw <- file2walking(acc_path, "Acc", walking)
ver_raw <- file2walking(ver_path, "Ver", walking)
hor_raw <- file2walking(hor_path, "Hor", walking)
snr_raw <- file2walking(snr_path, "S&R", walking)
walking <- rbind(walking, acc_raw)
walking <- rbind(walking, ver_raw)
walking <- rbind(walking, hor_raw)
walking <- rbind(walking, snr_raw)
colnames(walking) <- c("ID", "Condition", "Path")
#Compute Data for Walking and organise dataframes into larger dataframe
walkdata <- data.frame(ID=NA, Condition=NA, Time=NA, X=NA, Y=NA, Dist=NA, Velo=NA, Acce=NA)
walking$Walked <- 0 #Walked is cognitive user estimation
for (i in 1:nrow(walking)){
walking[i,]$Walked <- COGspatial[getrowindex(COGspatial, walking[i,]$ID, walking[i,]$Condition),]$Walked
}
walking$TotalWalked <- 0
walking$TotalTime <- 0
walking$AveSpeed <- 0
walking$MaxSpeed <- 0
walking$MinAccel <- 0
walking$MaxAccel <- 0
walking$CountGait <- 0
walking$CountRest <- 0
walksample =data.frame(Time=NA, X=NA, Y=NA, Dist=NA, Velo=NA, Acce=NA)
for (i in 1:1){
tempwalk <- read.csv(toString(walking[i,]$Path), header = FALSE, sep = ",")
tempwalk <- tempwalk[c(2:4)]
colnames(tempwalk) <- c("Time", "X", "Y")
tempwalk$Dist <- 0
tempwalk$Velo <- 0
tempwalk$Acce <- 0
#distance
for (x in 2:nrow(tempwalk)){
tempwalk$Dist[x] <- sqrt((tempwalk$X[x]-tempwalk$X[x-1])^2 + (tempwalk$Y[x]-tempwalk$Y[x-1])^2)
}
tempwalk <- tempwalk[as.integer(which(tempwalk$Dist==max(tempwalk$Dist))):(nrow(tempwalk)-10*60),]
#tighten to 3min
if (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1]>0) {
tempwalk <- tail(tempwalk, 3*60*60)
}
#velocity
for (x in 2:nrow(tempwalk)){
if(tempwalk$Time[x]==tempwalk$Time[x-1]) {
tempwalk$Velo[x] <- tempwalk$Velo[x-1]
}
else {
tempwalk$Velo[x] <- tempwalk$Dist[x]/(tempwalk$Time[x]-tempwalk$Time[x-1])
}
}
#acceleration
for (x in 3:nrow(tempwalk)) {
if (tempwalk$Time[x]==tempwalk$Time[x-1])
{
tempwalk$Acce[x] <- tempwalk$Acce[x-1]
}
else{
tempwalk$Acce[x] <- (tempwalk$Velo[x]-tempwalk$Velo[x-1])/(tempwalk$Time[x]- tempwalk$Time[x-1])
}
}
walkdata <- rbind(c(walking$ID[i], walking$Condition[i],tempwalk))
walking[i,]$TotalWalked <- sum(tempwalk$Dist)/100
walking[i,]$TotalTime <- (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1])/60
walking[i,]$AveSpeed <- walking[i,]$TotalWalked/walking[i,]$TotalTime * (1/60)
walking[i,]$MaxSpeed <- max(tempwalk$Velo) * (1/100)
walking[i,]$MinAccel <- min(tempwalk$Acce) * (1/100)
walking[i,]$MaxAccel <- max(tempwalk$Acce) * (1/100)
}
for (i in 2:nrow(walking)){
tempwalk <- read.csv(toString(walking[i,]$Path), header = FALSE, sep = ",")
tempwalk <- tempwalk[c(2:4)]
colnames(tempwalk) <- c("Time", "X", "Y")
tempwalk$Dist <- 0
tempwalk$Velo <- 0
tempwalk$Acce <- 0
#distance
for (x in 2:nrow(tempwalk)){
tempwalk$Dist[x] <- sqrt((tempwalk$X[x]-tempwalk$X[x-1])^2 + (tempwalk$Y[x]-tempwalk$Y[x-1])^2)
}
tempwalk <- tempwalk[as.integer(which(tempwalk$Dist==max(tempwalk$Dist))):(nrow(tempwalk)-10*60),]
#tighten to 3min
if (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1]>0) {
tempwalk <- tail(tempwalk, 3*60*60)
}
#velocity
for (x in 2:nrow(tempwalk)){
if(tempwalk$Time[x]==tempwalk$Time[x-1]) {
tempwalk$Velo[x] <- tempwalk$Velo[x-1]
}
else {
tempwalk$Velo[x] <- tempwalk$Dist[x]/(tempwalk$Time[x]-tempwalk$Time[x-1])
}
}
#acceleration
for (x in 3:nrow(tempwalk)) {
if (tempwalk$Time[x]==tempwalk$Time[x-1])
{
tempwalk$Acce[x] <- tempwalk$Acce[x-1]
}
else{
tempwalk$Acce[x] <- (tempwalk$Velo[x]-tempwalk$Velo[x-1])/(tempwalk$Time[x]- tempwalk$Time[x-1])
}
}
walkdata <- rbind(walkdata,c(walking$ID[i], walking$Condition[i],tempwalk))
walking[i,]$TotalWalked <- sum(tempwalk$Dist)/100
walking[i,]$TotalTime <- (tempwalk$Time[nrow(tempwalk)]-tempwalk$Time[1])/60
walking[i,]$AveSpeed <- walking[i,]$TotalWalked/walking[i,]$TotalTime * (1/60)
walking[i,]$MaxSpeed <- max(tempwalk$Velo) * (1/100)
walking[i,]$MinAccel <- min(tempwalk$Acce) * (1/100)
walking[i,]$MaxAccel <- max(tempwalk$Acce) * (1/100)
}
walking
#------Distance Accuracy------#
COGspatial$TotalWalked <- 0
COGspatial$AccuracyWalked <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
for (e in 1:length(index)) {
COGspatial[i,]$TotalWalked <- walking[index[e],]$TotalWalked + COGspatial[i,]$TotalWalked
}
}
else if (length(index)>0){
COGspatial[i,]$TotalWalked <- walking[index,]$TotalWalked
}
}
COGspatial$AccuracyWalked <- (COGspatial$Walked-COGspatial$TotalWalked)/COGspatial$TotalWalked
#stats
friedman.test(AccuracyWalked ~ Condition | ID, data = COGspatial)
friedman.test(TotalWalked ~ Condition | ID, data = COGspatial)
pw_twalked <- pairwise.wilcox.test(COGspatial$TotalWalked, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_twalked
createBoxplot(COGspatial,'TotalWalked',"Total Walked Distance",pw_twalked)
pw_awalked <- pairwise.wilcox.test(COGspatial$AccuracyWalked, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_awalked
createBoxplot(COGspatial,'AccuracyWalked',"Accuracy Walked Distance",pw_awalked)
#--------Velocity, Ave & Max (m/s)---------#
COGspatial$AveSpeed <- 0
COGspatial$MaxSpeed <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
sumtime <- sum(walking[index,]$TotalTime*60)
COGspatial[i,]$AveSpeed <- sum(walking[index,]$AveSpeed*walking[index,]$TotalTime*60)/(sumtime)
}
else if (length(index)>0){
COGspatial[i,]$AveSpeed <- walking[index,]$AveSpeed
COGspatial[i,]$MaxSpeed <- walking[index,]$MaxSpeed
}
}
#stats
friedman.test(AveSpeed ~ Condition | ID, data = COGspatial)
friedman.test(TotalWalked ~ Condition | ID, data = COGspatial)
pw_avespeed <- pairwise.wilcox.test(COGspatial$AveSpeed, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_avespeed
createBoxplot(COGspatial,'AveSpeed',"Average Speed (m/s)",pw_avespeed)
pw_maxspeed <- pairwise.wilcox.test(COGspatial$MaxSpeed, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_maxspeed
createBoxplot(COGspatial,'MaxSpeed',"Max Speed (m/s)",pw_maxspeed)
#--------Min/Max Acceleration (m/s^2)---------# Not Useful
COGspatial$MinAccel <- 0
COGspatial$MaxAccel <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
COGspatial[i,]$MinAccel <- min(walking[index,]$MinAccel)
COGspatial[i,]$MaxAccel <- max(walking[index,]$MaxAccel)
}
else if (length(index)>0){
COGspatial[i,]$MinAccel <- walking[index,]$MinAccel
COGspatial[i,]$MaxAccel <- walking[index,]$MaxAccel
}
}
#stats
friedman.test(MinAccel ~ Condition | ID, data = COGspatial)
friedman.test(MaxAccel ~ Condition | ID, data = COGspatial)
pw_minaccel <- pairwise.wilcox.test(COGspatial$MinAccel, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_minaccel
createBoxplot(COGspatial,'MinAccel',"Max Decceleration (m/s^2)",pw_minaccel)
pw_maxaccel <- pairwise.wilcox.test(COGspatial$MaxAccel, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_maxaccel
createBoxplot(COGspatial,'MaxSpeed',"Max Acceleration (m/s)",pw_maxaccel)
#--------Changes in Acceleration (m/s^2) to calculate continuous movement ---#
checksign <- function(value) {
if (value >= 0)
return(TRUE)
else (value < 0)
return(FALSE)
}
#calculate changes in acceleration
for (i in 1:nrow(walkdata)) { #nrow(walkdata)
count <- 0
tempcount <- 0
currentaccel <- TRUE
for (index in 2:length(walkdata[i,]$Acce)) {
if (checksign(walkdata[i,]$Acce[index]) != checksign(walkdata[i,]$Acce[index-1])) {
tempcount <- tempcount + 1
if (tempcount > 59) { #if the acceleration/decceration is more than a second
count <- count + 1
tempcount <- 0
}
}
}
walking[i,]$CountGait <- count
}
#input into COGspatial
COGspatial$CountGait <- 0
for (i in 1:nrow(COGspatial)){
index = getrowindex(walking, COGspatial[i,]$ID, COGspatial[i,]$Condition)
if (length(index)>1){
COGspatial[i,]$CountGait <- sum(walking[index,]$CountGait)
}
else if (length(index)>0){
COGspatial[i,]$CountGait <- walking[index,]$CountGait
}
}
#stats
friedman.test(CountGait ~ Condition | ID, data = COGspatial)
pw_countgait <- pairwise.wilcox.test(COGspatial$CountGait, COGspatial$Condition,
p.adjust.method = "bonferroni",
paired = TRUE)
pw_countgait
createBoxplot(COGspatial,'CountGait',"Changes in Acceleration (sustained over min. 1sec)",pw_countgait)
